#! /usr/bin/env bqn

crâ€¿lf â† @+13â€¿10

Log â† â€¢term.ErrRaw
Logln â† Log âˆ¾âŸœlf

# Codepoint to UTF-8
cpToUTF8 â† {
    Cnt â† 128 + 64âŠ¸|    # make continuation byte
    Shr â† âŒŠ âŠ¢ Ã· â‹†ËœâŸœ2    # ğ•© >> ğ•¨
    {
        ğ•© < 2â‹† 7? âŸ¨             ğ•©                                  âŸ© ;
        ğ•© < 2â‹†11? âŸ¨192 +  6 Shr ğ•©,                            Cnt ğ•©âŸ© ;
        ğ•© < 2â‹†16? âŸ¨224 + 12 Shr ğ•©,               Cnt 6 Shr ğ•©, Cnt ğ•©âŸ© ;
                  âŸ¨240 + 18 Shr ğ•©, Cnt 12 Shr ğ•©, Cnt 6 Shr ğ•©, Cnt ğ•©âŸ©
    }
}
ToUTF8 â† âˆ¾ âˆ˜ (CpToUTF8Â¨ âˆ˜ -âŸœ@)
! 226â€¿138â€¿145â€¿240â€¿157â€¿149â€¿168â€¿47â€¿240â€¿157â€¿149â€¿169 â‰¡ ToUTF8 "âŠ‘ğ•¨/ğ•©"    # [*"âŠ‘ğ•¨/ğ•©".encode('utf-8')]

# https://github.com/dzaima/CBQN/blob/master/docs/system.md#term
SendUTF8 â† {
    "sending more than 512 bytes" ! 510 â‰¥ â‰ ğ•©
    Logln ">>> "âˆ¾ğ•©
    â€¢term.OutRaw ğ•©âˆ¾crâ€¿lf
    â€¢term.Flush @
}
Send â† SendUTF8âˆ˜ToUTF8

Parse â† { ğ•Š in: 
    in â†“Ëœâ†© - âŠ‘âŠâŸœ0 âŒ½ (crâŠ¸= âˆ¨ lfâŠ¸=) in    # remove line endings
    spcâ€¿cln â† inâŠ¸=Â¨ " :"
    cln â†© Â¬ âŸ¨1âŸ©âŠ’ 0 Â» spc âˆ§ 0Â«cln    # keep only when followed by spaces
    wds â† (Ã—â‰ Â¨)âŠ¸/ in âŠ”Ëœ (âŠ¢ -Ëœ Â¬ âˆ§ +`) clnâˆ¨ spcâˆ§ Â¬âˆ¨`cln    # strips colons too!
    wds âˆ¾âŸœâŸ¨""âŸ©âŸ(Â¯1 âŠ‘ cln)â†©    # if the colon is at the end, add an empty argument
    src â† ""
    { ğ•Š: src â†© 1 â†“ âŠ‘wds â‹„ wds â†“Ëœâ†© 1} âŸ âŠ¢ (':'=âŠ‘in)
    âŸ¨src, âŠ‘ wds, 1 â†“ wdsâŸ©    # srcâ€¿nameâ€¿args
}
! "pig"â€¿"PRIVMSG"â€¿("#a"â€¿":  bee sus") â‰¡ Parse ":pig PRIVMSG  #a  ::  bee sus"âˆ¾crâ€¿lf
! ""â€¿"pig"â€¿("PRIVMSG"â€¿"#a"â€¿"among"â€¿"us") â‰¡ Parse "pig PRIVMSG  #a    among us"
! "irc.example.com"â€¿"CAP"â€¿("*"â€¿"LIST"â€¿"") â‰¡ Parse ":irc.example.com CAP * LIST :"âˆ¾(10/â‹ˆcr)âˆ¾lf
! "AutoBotRobot"â€¿"PRIVMSG"â€¿("#b"â€¿"<9DrakeBot> :tada: Congratulations to") â‰¡ {
    Parse ":AutoBotRobot PRIVMSG #b :<9DrakeBot> :tada: Congratulations to"
}

SplitCommand â† âŠ‘âˆ˜âŠâŸœ' ' âŠ¸ (â†‘ â‹ˆ 1âŠ¸+âŠ¸â†“)

Choose â† {
    ğ•Š Â·â€¿"STARTPLZ"â€¿Â·:
        # this is not actually an irc command. it is sent by the shell file to tell this file to 
        # send the login commands and shit
        Send "NICK pig"
        Send "USER pig 0 * pig"
    ;
    ğ•Š Â·â€¿"001"â€¿Â·:
        Send "MODE pig +x"
        Send "JOIN #b"
        Send "PRIVMSG #b ğŸ–"
        # Send "WHOIS pig"
    ;
    ğ•Š Â·â€¿"PING"â€¿args:
        Send {0=â‰ args? "PONG" ; "PONG :"âˆ¾Â¯1âŠ‘args}
        #Send "PRIVMSG #aa oink"
    ;
    ğ•Š srcâ€¿"PRIVMSG"â€¿(chanâ€¿msg):
    âˆ¨Â´ pigs â† "pig " â· " " âˆ¾Ëœ msg?
        nameâ€¿args â† SplitCommand msg â†“Ëœ 4 + âŠ‘/pigs
        {srcâ‡src,chanâ‡chan,argsâ‡args} ChooseCommandâŠ({
            ğ•¨ Say "*vomits on ground*"
            Logln "!!! "âˆ¾ğ•©
        }âŸœâ€¢CurrentError) name
    ; @
}

Saylns â† {
    start â† ToUTF8 "PRIVMSG "âˆ¾ğ•¨.chanâˆ¾" :"
    bytes â† 400    # maximum bytes to send. might be adjusted to something better later
    utf â† CpToUTF8âˆ˜-âŸœ@Â¨ ğ•©
    lfs â† lf = ğ•©
    lines â† utf âŠ”Ëœ lfs (Â¬âˆ˜âŠ£âŠ¸âˆ§ - âŠ£) âŠ‘Â¨ {
        aâ€¿b ğ•Š lâ€¿x: {l âˆ¨ bytes<b+x? âŸ¨a+1, lÃ—xâŸ©; âŸ¨a, b+xâŸ©}
    }` lfs (âŠ£â‹ˆÂ·â‰ âŠ¢)Â¨ utf    # this might be possible with a 2d array, maybe
    SendUTF8âˆ˜(start âˆ¾ âˆ¾)Â¨ lines
}

Say â† {Send "PRIVMSG "âˆ¾ğ•¨.chanâˆ¾" :"âˆ¾ğ•©}

keyfm â† "`123456890-=~!@#$%^&*()_+qwertuiop[]QWERTIOP{}asdfghjkl;ASFGHKL:zxcvbm,./ZXVBM<>? '\"""
keyto â† "ËœË˜Â¨â¼âŒœÂ´ËâˆÂ¯â€¢Ã·Ã—Â¬â‰âš‡âŸâ—¶âŠ˜âŠââ•âŸ¨âŸ©âˆšâ‹†âŒ½ğ•¨âˆŠâ†‘âˆ§âŠ”âŠâŠÏ€â†â†’â†™ğ•â·ğ•£â‹âŠ‘âŠ’â³âŠ£âŠ¢â‰ğ•¤â†•ğ•—ğ•˜âŠ¸âˆ˜â—‹âŸœâ‹„â†–ğ•Šğ”½ğ”¾Â«âŒ¾Â»Â·â¥Šğ•©â†“âˆ¨âŒŠâ‰¡âˆ¾â‰â‰ â‹ˆğ•â’âŒˆâ‰¢â‰¤â‰¥â‡â€¿â†©\Ë™ğŸ–"
# ğŸ– will be used when no escape is found

susBQN â† â€¢ReBQN {replâ‡"loose",scopeâ‡"none"}
susBQNÂ¨ "randâ†â€¢rand"â€¿"mathâ†â€¢math"â€¿"Fmtâ†â€¢Fmt"â€¿"Typeâ†â€¢Type"â€¿"UnixTimeâ†â€¢UnixTime"â€¿"Glyphâ†â€¢Glyph"

Unescape â† {
    code â† ğ•© (âŠ£ â†“ -âŠ¸â†“)Ëœ (âŠ‘âˆ˜âŠâŸœ0 âŒŠ âŠ‘âˆ˜âŠâŸœ0âˆ˜âŒ½) '`' = ğ•©   # removes as many ticks it can
    bsls â† Â¬âŠ¸âˆ¨` '\' â‰  code    # in \\ only the first backslash should be escaped
    (âŠ¢ /Ëœ bsls âˆ§ 'â€¢'âŠ¸â‰ ) (keyto âŠËœ keyfm âŠâŠ¢)âŒ¾((Â»Â¬bsls)âŠ¸/) code
}

Pick â† â€¢rand.Rangeâˆ˜â‰  âŠ‘ âŠ¢
ChooseCommand â† {
    cx ğ•Š "say":
        cx Say cx.args
    ;
    cx ğ•Š "do":
        cx Saylns {1 = =ğ•©? âˆ§Â´ 2 = â€¢TypeÂ¨ ğ•©? ğ•©; â€¢Fmt ğ•©}âˆ˜SusBQNâŠ("Error: "âˆ¾â€¢CurrentError) Unescape cx.args
    ;
    cx ğ•Š "perform":
        cx ChooseCommand "unescape"
        cx ChooseCommand "do"
    ;
    cx ğ•Š "unescape":
        cx Saylns ("```"âŠ¸âˆ¾âˆ¾âŸœ"```") Unescape cx.args
    ;
    cx ğ•Š "join": Â¬ âˆ¨Â´ " ," âˆŠ cx.args? '#' = âŠ‘ cx.args?
        cx Say "omw"
        Send "JOIN "âˆ¾cx.args
    ;
    cx ğ•Š "leave":
        cx Say "omw"
        Send "PART "âˆ¾cx.chan
    ;
    cx ğ•Š "please":
        nameâ€¿args â† SplitCommand cx.args
        {srcâ‡ cx.src, chanâ‡ cx.chan, argsâ‡ args} ChooseCommand name
        cx Say âˆ¾ PickÂ¨ âŸ¨
            âŸ¨"my pleasure"
             "forget it"
             "not at all"
             "yw"
             "np"âŸ©âˆ¾ 2/âŸ¨"you're welcome"
                       "no problem"
                       "it's nothing"
                       "it's a pleasure"
                       "no worries"âŸ©
            âŸ¨"!!"âŸ© âˆ¾ 2/"!"â€¿""
            " :D"â€¿" :>"â€¿" :]" âˆ¾ 2/" c:"â€¿" :)"â€¿""
        âŸ©
    ;
    cx ğ•Š cmd:
        cx Say "oink"
}

Main â† {ğ•Š:
    Logln "starting..."

    { ğ•Š:
        Log "... "
        (Chooseâˆ˜Parse @Ë™ Logln) â€¢GetLine @
    } â€¢_while_ 1 @
}


MainâŸ{ğ•Š:"run"â‰¡âŠ‘â€¢args}âŸ(1â‰¤â‰ â€¢args) @